// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: pricing_zones.sql

package pgstore

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CountPricingZones = `-- name: CountPricingZones :one
SELECT COUNT(*) FROM pricing_zones
`

func (q *Queries) CountPricingZones(ctx context.Context, db DBTX) (int64, error) {
	row := db.QueryRow(ctx, CountPricingZones)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const DeletePricingZone = `-- name: DeletePricingZone :exec
DELETE FROM pricing_zones WHERE iso_code = $1
`

func (q *Queries) DeletePricingZone(ctx context.Context, db DBTX, isoCode string) error {
	_, err := db.Exec(ctx, DeletePricingZone, isoCode)
	return err
}

const GetPricingZoneByCountry = `-- name: GetPricingZoneByCountry :one
SELECT id, country, iso_code, zone, zone_name, world_bank_classification, 
       gni_per_capita_threshold, pricing_multiplier, created_at, updated_at
FROM pricing_zones 
WHERE LOWER(country) = LOWER($1)
`

func (q *Queries) GetPricingZoneByCountry(ctx context.Context, db DBTX, lower string) (*PricingZone, error) {
	row := db.QueryRow(ctx, GetPricingZoneByCountry, lower)
	var i PricingZone
	err := row.Scan(
		&i.ID,
		&i.Country,
		&i.IsoCode,
		&i.Zone,
		&i.ZoneName,
		&i.WorldBankClassification,
		&i.GniPerCapitaThreshold,
		&i.PricingMultiplier,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetPricingZoneByISOCode = `-- name: GetPricingZoneByISOCode :one
SELECT id, country, iso_code, zone, zone_name, world_bank_classification, 
       gni_per_capita_threshold, pricing_multiplier, created_at, updated_at
FROM pricing_zones 
WHERE iso_code = $1
`

func (q *Queries) GetPricingZoneByISOCode(ctx context.Context, db DBTX, isoCode string) (*PricingZone, error) {
	row := db.QueryRow(ctx, GetPricingZoneByISOCode, isoCode)
	var i PricingZone
	err := row.Scan(
		&i.ID,
		&i.Country,
		&i.IsoCode,
		&i.Zone,
		&i.ZoneName,
		&i.WorldBankClassification,
		&i.GniPerCapitaThreshold,
		&i.PricingMultiplier,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetPricingZonesByZone = `-- name: GetPricingZonesByZone :many
SELECT id, country, iso_code, zone, zone_name, world_bank_classification, 
       gni_per_capita_threshold, pricing_multiplier, created_at, updated_at
FROM pricing_zones 
WHERE zone = $1
ORDER BY country
`

func (q *Queries) GetPricingZonesByZone(ctx context.Context, db DBTX, zone string) ([]*PricingZone, error) {
	rows, err := db.Query(ctx, GetPricingZonesByZone, zone)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*PricingZone{}
	for rows.Next() {
		var i PricingZone
		if err := rows.Scan(
			&i.ID,
			&i.Country,
			&i.IsoCode,
			&i.Zone,
			&i.ZoneName,
			&i.WorldBankClassification,
			&i.GniPerCapitaThreshold,
			&i.PricingMultiplier,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListPricingZones = `-- name: ListPricingZones :many
SELECT id, country, iso_code, zone, zone_name, world_bank_classification, 
       gni_per_capita_threshold, pricing_multiplier, created_at, updated_at
FROM pricing_zones 
ORDER BY zone, country
`

func (q *Queries) ListPricingZones(ctx context.Context, db DBTX) ([]*PricingZone, error) {
	rows, err := db.Query(ctx, ListPricingZones)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*PricingZone{}
	for rows.Next() {
		var i PricingZone
		if err := rows.Scan(
			&i.ID,
			&i.Country,
			&i.IsoCode,
			&i.Zone,
			&i.ZoneName,
			&i.WorldBankClassification,
			&i.GniPerCapitaThreshold,
			&i.PricingMultiplier,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpsertPricingZone = `-- name: UpsertPricingZone :one
INSERT INTO pricing_zones (
    country, iso_code, zone, zone_name, world_bank_classification, 
    gni_per_capita_threshold, pricing_multiplier
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
ON CONFLICT (iso_code) DO UPDATE SET
    country = EXCLUDED.country,
    zone = EXCLUDED.zone,
    zone_name = EXCLUDED.zone_name,
    world_bank_classification = EXCLUDED.world_bank_classification,
    gni_per_capita_threshold = EXCLUDED.gni_per_capita_threshold,
    pricing_multiplier = EXCLUDED.pricing_multiplier,
    updated_at = NOW()
RETURNING id, country, iso_code, zone, zone_name, world_bank_classification, 
          gni_per_capita_threshold, pricing_multiplier, created_at, updated_at
`

type UpsertPricingZoneParams struct {
	Country                 string         `json:"country"`
	IsoCode                 string         `json:"iso_code"`
	Zone                    string         `json:"zone"`
	ZoneName                string         `json:"zone_name"`
	WorldBankClassification pgtype.Text    `json:"world_bank_classification"`
	GniPerCapitaThreshold   pgtype.Text    `json:"gni_per_capita_threshold"`
	PricingMultiplier       pgtype.Numeric `json:"pricing_multiplier"`
}

func (q *Queries) UpsertPricingZone(ctx context.Context, db DBTX, arg UpsertPricingZoneParams) (*PricingZone, error) {
	row := db.QueryRow(ctx, UpsertPricingZone,
		arg.Country,
		arg.IsoCode,
		arg.Zone,
		arg.ZoneName,
		arg.WorldBankClassification,
		arg.GniPerCapitaThreshold,
		arg.PricingMultiplier,
	)
	var i PricingZone
	err := row.Scan(
		&i.ID,
		&i.Country,
		&i.IsoCode,
		&i.Zone,
		&i.ZoneName,
		&i.WorldBankClassification,
		&i.GniPerCapitaThreshold,
		&i.PricingMultiplier,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
