// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: usage.sql

package pgstore

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CreateUsage = `-- name: CreateUsage :exec
INSERT INTO usage (
    user_id, family_id, feature_code, resource_type, resource_size, operation, metadata
) VALUES (
    $1, $2, $3, 
    $4, $5, $6, $7
)
`

type CreateUsageParams struct {
	UserID       string      `json:"user_id"`
	FamilyID     pgtype.Text `json:"family_id"`
	FeatureCode  string      `json:"feature_code"`
	ResourceType string      `json:"resource_type"`
	ResourceSize int64       `json:"resource_size"`
	Operation    pgtype.Text `json:"operation"`
	Metadata     []byte      `json:"metadata"`
}

func (q *Queries) CreateUsage(ctx context.Context, db DBTX, arg CreateUsageParams) error {
	_, err := db.Exec(ctx, CreateUsage,
		arg.UserID,
		arg.FamilyID,
		arg.FeatureCode,
		arg.ResourceType,
		arg.ResourceSize,
		arg.Operation,
		arg.Metadata,
	)
	return err
}

const DeleteUsage = `-- name: DeleteUsage :exec
DELETE FROM usage 
WHERE user_id = $1 
  AND feature_code = $2 
  AND resource_type = $3
`

type DeleteUsageParams struct {
	UserID       string `json:"user_id"`
	FeatureCode  string `json:"feature_code"`
	ResourceType string `json:"resource_type"`
}

func (q *Queries) DeleteUsage(ctx context.Context, db DBTX, arg DeleteUsageParams) error {
	_, err := db.Exec(ctx, DeleteUsage, arg.UserID, arg.FeatureCode, arg.ResourceType)
	return err
}

const GetCurrentUsage = `-- name: GetCurrentUsage :one
SELECT COALESCE(SUM(resource_size), 0) as total_usage
FROM usage 
WHERE user_id = $1 
  AND feature_code = $2 
  AND resource_type = $3
  AND created_at >= $4
`

type GetCurrentUsageParams struct {
	UserID       string             `json:"user_id"`
	FeatureCode  string             `json:"feature_code"`
	ResourceType string             `json:"resource_type"`
	Since        pgtype.Timestamptz `json:"since"`
}

func (q *Queries) GetCurrentUsage(ctx context.Context, db DBTX, arg GetCurrentUsageParams) (interface{}, error) {
	row := db.QueryRow(ctx, GetCurrentUsage,
		arg.UserID,
		arg.FeatureCode,
		arg.ResourceType,
		arg.Since,
	)
	var total_usage interface{}
	err := row.Scan(&total_usage)
	return total_usage, err
}

const GetUsageByID = `-- name: GetUsageByID :one
SELECT id, user_id, family_id, feature_code, resource_type, resource_size, operation, metadata, created_at FROM usage WHERE id = $1
`

func (q *Queries) GetUsageByID(ctx context.Context, db DBTX, id pgtype.UUID) (*Usage, error) {
	row := db.QueryRow(ctx, GetUsageByID, id)
	var i Usage
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FamilyID,
		&i.FeatureCode,
		&i.ResourceType,
		&i.ResourceSize,
		&i.Operation,
		&i.Metadata,
		&i.CreatedAt,
	)
	return &i, err
}

const GetUsageHistory = `-- name: GetUsageHistory :many
SELECT id, user_id, family_id, feature_code, resource_type, resource_size, operation, metadata, created_at FROM usage 
WHERE user_id = $1 
  AND feature_code = $2 
  AND resource_type = $3
  AND created_at >= $4
ORDER BY created_at DESC
`

type GetUsageHistoryParams struct {
	UserID       string             `json:"user_id"`
	FeatureCode  string             `json:"feature_code"`
	ResourceType string             `json:"resource_type"`
	Since        pgtype.Timestamptz `json:"since"`
}

func (q *Queries) GetUsageHistory(ctx context.Context, db DBTX, arg GetUsageHistoryParams) ([]*Usage, error) {
	rows, err := db.Query(ctx, GetUsageHistory,
		arg.UserID,
		arg.FeatureCode,
		arg.ResourceType,
		arg.Since,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Usage{}
	for rows.Next() {
		var i Usage
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FamilyID,
			&i.FeatureCode,
			&i.ResourceType,
			&i.ResourceSize,
			&i.Operation,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUsageStats = `-- name: GetUsageStats :many
SELECT 
    feature_code,
    resource_type,
    COUNT(*) as usage_count,
    SUM(resource_size) as total_size,
    MIN(created_at) as first_usage,
    MAX(created_at) as last_usage
FROM usage 
WHERE user_id = $1 
  AND created_at >= $2
GROUP BY feature_code, resource_type
ORDER BY total_size DESC
`

type GetUsageStatsParams struct {
	UserID string             `json:"user_id"`
	Since  pgtype.Timestamptz `json:"since"`
}

type GetUsageStatsRow struct {
	FeatureCode  string      `json:"feature_code"`
	ResourceType string      `json:"resource_type"`
	UsageCount   int64       `json:"usage_count"`
	TotalSize    int64       `json:"total_size"`
	FirstUsage   interface{} `json:"first_usage"`
	LastUsage    interface{} `json:"last_usage"`
}

func (q *Queries) GetUsageStats(ctx context.Context, db DBTX, arg GetUsageStatsParams) ([]*GetUsageStatsRow, error) {
	rows, err := db.Query(ctx, GetUsageStats, arg.UserID, arg.Since)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetUsageStatsRow{}
	for rows.Next() {
		var i GetUsageStatsRow
		if err := rows.Scan(
			&i.FeatureCode,
			&i.ResourceType,
			&i.UsageCount,
			&i.TotalSize,
			&i.FirstUsage,
			&i.LastUsage,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListUsageByUser = `-- name: ListUsageByUser :many
SELECT id, user_id, family_id, feature_code, resource_type, resource_size, operation, metadata, created_at FROM usage 
WHERE user_id = $1 
ORDER BY created_at DESC
LIMIT $3 OFFSET $2
`

type ListUsageByUserParams struct {
	UserID      string `json:"user_id"`
	OffsetCount int32  `json:"offset_count"`
	LimitCount  int32  `json:"limit_count"`
}

func (q *Queries) ListUsageByUser(ctx context.Context, db DBTX, arg ListUsageByUserParams) ([]*Usage, error) {
	rows, err := db.Query(ctx, ListUsageByUser, arg.UserID, arg.OffsetCount, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Usage{}
	for rows.Next() {
		var i Usage
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FamilyID,
			&i.FeatureCode,
			&i.ResourceType,
			&i.ResourceSize,
			&i.Operation,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
