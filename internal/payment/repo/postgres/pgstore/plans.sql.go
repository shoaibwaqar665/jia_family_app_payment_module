// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: plans.sql

package pgstore

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const GetPlanByID = `-- name: GetPlanByID :one
SELECT id, name, description, feature_codes, billing_cycle, price_cents, currency, max_users, usage_limits, metadata, active, created_at, updated_at FROM plans 
WHERE id = $1 AND active = true
`

func (q *Queries) GetPlanByID(ctx context.Context, db DBTX, id string) (*Plan, error) {
	row := db.QueryRow(ctx, GetPlanByID, id)
	var i Plan
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.FeatureCodes,
		&i.BillingCycle,
		&i.PriceCents,
		&i.Currency,
		&i.MaxUsers,
		&i.UsageLimits,
		&i.Metadata,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const InsertPlan = `-- name: InsertPlan :one
INSERT INTO plans (
    id, name, description, feature_codes, billing_cycle,
    price_cents, currency, max_users, usage_limits, metadata, active
) VALUES (
    $1, $2, $3, 
    $4, $5,
    $6, $7, $8,
    $9, $10, $11
) RETURNING id, name, description, feature_codes, billing_cycle, price_cents, currency, max_users, usage_limits, metadata, active, created_at, updated_at
`

type InsertPlanParams struct {
	ID           string      `json:"id"`
	Name         string      `json:"name"`
	Description  pgtype.Text `json:"description"`
	FeatureCodes []string    `json:"feature_codes"`
	BillingCycle pgtype.Text `json:"billing_cycle"`
	PriceCents   int32       `json:"price_cents"`
	Currency     string      `json:"currency"`
	MaxUsers     pgtype.Int4 `json:"max_users"`
	UsageLimits  []byte      `json:"usage_limits"`
	Metadata     []byte      `json:"metadata"`
	Active       bool        `json:"active"`
}

func (q *Queries) InsertPlan(ctx context.Context, db DBTX, arg InsertPlanParams) (*Plan, error) {
	row := db.QueryRow(ctx, InsertPlan,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.FeatureCodes,
		arg.BillingCycle,
		arg.PriceCents,
		arg.Currency,
		arg.MaxUsers,
		arg.UsageLimits,
		arg.Metadata,
		arg.Active,
	)
	var i Plan
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.FeatureCodes,
		&i.BillingCycle,
		&i.PriceCents,
		&i.Currency,
		&i.MaxUsers,
		&i.UsageLimits,
		&i.Metadata,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const ListActivePlans = `-- name: ListActivePlans :many
SELECT id, name, description, feature_codes, billing_cycle, price_cents, currency, max_users, usage_limits, metadata, active, created_at, updated_at FROM plans 
WHERE active = true 
ORDER BY created_at DESC
`

func (q *Queries) ListActivePlans(ctx context.Context, db DBTX) ([]*Plan, error) {
	rows, err := db.Query(ctx, ListActivePlans)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Plan{}
	for rows.Next() {
		var i Plan
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.FeatureCodes,
			&i.BillingCycle,
			&i.PriceCents,
			&i.Currency,
			&i.MaxUsers,
			&i.UsageLimits,
			&i.Metadata,
			&i.Active,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdatePlanActive = `-- name: UpdatePlanActive :one
UPDATE plans 
SET active = $1, updated_at = NOW()
WHERE id = $2
RETURNING id, name, description, feature_codes, billing_cycle, price_cents, currency, max_users, usage_limits, metadata, active, created_at, updated_at
`

type UpdatePlanActiveParams struct {
	Active bool   `json:"active"`
	ID     string `json:"id"`
}

func (q *Queries) UpdatePlanActive(ctx context.Context, db DBTX, arg UpdatePlanActiveParams) (*Plan, error) {
	row := db.QueryRow(ctx, UpdatePlanActive, arg.Active, arg.ID)
	var i Plan
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.FeatureCodes,
		&i.BillingCycle,
		&i.PriceCents,
		&i.Currency,
		&i.MaxUsers,
		&i.UsageLimits,
		&i.Metadata,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
