// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: subscriptions.sql

package pgstore

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CreateSubscription = `-- name: CreateSubscription :one
INSERT INTO subscriptions (
    user_id, family_id, plan_id, status, current_period_start, 
    current_period_end, cancel_at_period_end, external_subscription_id, metadata
) VALUES (
    $1, $2, $3, 
    $4, $5, $6,
    $7, $8, $9
) RETURNING id, user_id, family_id, plan_id, status, current_period_start, current_period_end, cancel_at_period_end, cancelled_at, external_subscription_id, metadata, created_at, updated_at
`

type CreateSubscriptionParams struct {
	UserID                 string             `json:"user_id"`
	FamilyID               pgtype.Text        `json:"family_id"`
	PlanID                 pgtype.UUID        `json:"plan_id"`
	Status                 string             `json:"status"`
	CurrentPeriodStart     pgtype.Timestamptz `json:"current_period_start"`
	CurrentPeriodEnd       pgtype.Timestamptz `json:"current_period_end"`
	CancelAtPeriodEnd      bool               `json:"cancel_at_period_end"`
	ExternalSubscriptionID pgtype.Text        `json:"external_subscription_id"`
	Metadata               []byte             `json:"metadata"`
}

func (q *Queries) CreateSubscription(ctx context.Context, db DBTX, arg CreateSubscriptionParams) (*Subscription, error) {
	row := db.QueryRow(ctx, CreateSubscription,
		arg.UserID,
		arg.FamilyID,
		arg.PlanID,
		arg.Status,
		arg.CurrentPeriodStart,
		arg.CurrentPeriodEnd,
		arg.CancelAtPeriodEnd,
		arg.ExternalSubscriptionID,
		arg.Metadata,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FamilyID,
		&i.PlanID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.CancelAtPeriodEnd,
		&i.CancelledAt,
		&i.ExternalSubscriptionID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const DeleteSubscription = `-- name: DeleteSubscription :exec
DELETE FROM subscriptions WHERE id = $1
`

func (q *Queries) DeleteSubscription(ctx context.Context, db DBTX, id pgtype.UUID) error {
	_, err := db.Exec(ctx, DeleteSubscription, id)
	return err
}

const GetActiveSubscriptions = `-- name: GetActiveSubscriptions :many
SELECT id, user_id, family_id, plan_id, status, current_period_start, current_period_end, cancel_at_period_end, cancelled_at, external_subscription_id, metadata, created_at, updated_at FROM subscriptions WHERE status = 'active' ORDER BY created_at DESC
`

func (q *Queries) GetActiveSubscriptions(ctx context.Context, db DBTX) ([]*Subscription, error) {
	rows, err := db.Query(ctx, GetActiveSubscriptions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FamilyID,
			&i.PlanID,
			&i.Status,
			&i.CurrentPeriodStart,
			&i.CurrentPeriodEnd,
			&i.CancelAtPeriodEnd,
			&i.CancelledAt,
			&i.ExternalSubscriptionID,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetExpiringSubscriptions = `-- name: GetExpiringSubscriptions :many
SELECT id, user_id, family_id, plan_id, status, current_period_start, current_period_end, cancel_at_period_end, cancelled_at, external_subscription_id, metadata, created_at, updated_at FROM subscriptions 
WHERE current_period_end <= $1 
  AND status = 'active'
ORDER BY current_period_end ASC
`

func (q *Queries) GetExpiringSubscriptions(ctx context.Context, db DBTX, beforeDate pgtype.Timestamptz) ([]*Subscription, error) {
	rows, err := db.Query(ctx, GetExpiringSubscriptions, beforeDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FamilyID,
			&i.PlanID,
			&i.Status,
			&i.CurrentPeriodStart,
			&i.CurrentPeriodEnd,
			&i.CancelAtPeriodEnd,
			&i.CancelledAt,
			&i.ExternalSubscriptionID,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetSubscriptionByExternalID = `-- name: GetSubscriptionByExternalID :one
SELECT id, user_id, family_id, plan_id, status, current_period_start, current_period_end, cancel_at_period_end, cancelled_at, external_subscription_id, metadata, created_at, updated_at FROM subscriptions WHERE external_subscription_id = $1
`

func (q *Queries) GetSubscriptionByExternalID(ctx context.Context, db DBTX, externalID pgtype.Text) (*Subscription, error) {
	row := db.QueryRow(ctx, GetSubscriptionByExternalID, externalID)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FamilyID,
		&i.PlanID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.CancelAtPeriodEnd,
		&i.CancelledAt,
		&i.ExternalSubscriptionID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetSubscriptionByID = `-- name: GetSubscriptionByID :one
SELECT id, user_id, family_id, plan_id, status, current_period_start, current_period_end, cancel_at_period_end, cancelled_at, external_subscription_id, metadata, created_at, updated_at FROM subscriptions WHERE id = $1
`

func (q *Queries) GetSubscriptionByID(ctx context.Context, db DBTX, id pgtype.UUID) (*Subscription, error) {
	row := db.QueryRow(ctx, GetSubscriptionByID, id)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FamilyID,
		&i.PlanID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.CancelAtPeriodEnd,
		&i.CancelledAt,
		&i.ExternalSubscriptionID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetSubscriptionsByPlan = `-- name: GetSubscriptionsByPlan :many
SELECT id, user_id, family_id, plan_id, status, current_period_start, current_period_end, cancel_at_period_end, cancelled_at, external_subscription_id, metadata, created_at, updated_at FROM subscriptions WHERE plan_id = $1 ORDER BY created_at DESC
`

func (q *Queries) GetSubscriptionsByPlan(ctx context.Context, db DBTX, planID pgtype.UUID) ([]*Subscription, error) {
	rows, err := db.Query(ctx, GetSubscriptionsByPlan, planID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FamilyID,
			&i.PlanID,
			&i.Status,
			&i.CurrentPeriodStart,
			&i.CurrentPeriodEnd,
			&i.CancelAtPeriodEnd,
			&i.CancelledAt,
			&i.ExternalSubscriptionID,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetSubscriptionsByStatus = `-- name: GetSubscriptionsByStatus :many
SELECT id, user_id, family_id, plan_id, status, current_period_start, current_period_end, cancel_at_period_end, cancelled_at, external_subscription_id, metadata, created_at, updated_at FROM subscriptions WHERE status = $1 ORDER BY created_at DESC
`

func (q *Queries) GetSubscriptionsByStatus(ctx context.Context, db DBTX, status string) ([]*Subscription, error) {
	rows, err := db.Query(ctx, GetSubscriptionsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FamilyID,
			&i.PlanID,
			&i.Status,
			&i.CurrentPeriodStart,
			&i.CurrentPeriodEnd,
			&i.CancelAtPeriodEnd,
			&i.CancelledAt,
			&i.ExternalSubscriptionID,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetSubscriptionsByUserID = `-- name: GetSubscriptionsByUserID :many
SELECT id, user_id, family_id, plan_id, status, current_period_start, current_period_end, cancel_at_period_end, cancelled_at, external_subscription_id, metadata, created_at, updated_at FROM subscriptions WHERE user_id = $1 ORDER BY created_at DESC
`

func (q *Queries) GetSubscriptionsByUserID(ctx context.Context, db DBTX, userID string) ([]*Subscription, error) {
	rows, err := db.Query(ctx, GetSubscriptionsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FamilyID,
			&i.PlanID,
			&i.Status,
			&i.CurrentPeriodStart,
			&i.CurrentPeriodEnd,
			&i.CancelAtPeriodEnd,
			&i.CancelledAt,
			&i.ExternalSubscriptionID,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const RenewSubscription = `-- name: RenewSubscription :one
UPDATE subscriptions SET
    current_period_start = $1,
    current_period_end = $2,
    updated_at = NOW()
WHERE id = $3
RETURNING id, user_id, family_id, plan_id, status, current_period_start, current_period_end, cancel_at_period_end, cancelled_at, external_subscription_id, metadata, created_at, updated_at
`

type RenewSubscriptionParams struct {
	NewPeriodStart pgtype.Timestamptz `json:"new_period_start"`
	NewPeriodEnd   pgtype.Timestamptz `json:"new_period_end"`
	ID             pgtype.UUID        `json:"id"`
}

func (q *Queries) RenewSubscription(ctx context.Context, db DBTX, arg RenewSubscriptionParams) (*Subscription, error) {
	row := db.QueryRow(ctx, RenewSubscription, arg.NewPeriodStart, arg.NewPeriodEnd, arg.ID)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FamilyID,
		&i.PlanID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.CancelAtPeriodEnd,
		&i.CancelledAt,
		&i.ExternalSubscriptionID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UpdateSubscription = `-- name: UpdateSubscription :one
UPDATE subscriptions SET
    status = $1,
    current_period_start = $2,
    current_period_end = $3,
    cancel_at_period_end = $4,
    cancelled_at = $5,
    metadata = $6,
    updated_at = NOW()
WHERE id = $7
RETURNING id, user_id, family_id, plan_id, status, current_period_start, current_period_end, cancel_at_period_end, cancelled_at, external_subscription_id, metadata, created_at, updated_at
`

type UpdateSubscriptionParams struct {
	Status             string             `json:"status"`
	CurrentPeriodStart pgtype.Timestamptz `json:"current_period_start"`
	CurrentPeriodEnd   pgtype.Timestamptz `json:"current_period_end"`
	CancelAtPeriodEnd  bool               `json:"cancel_at_period_end"`
	CancelledAt        pgtype.Timestamptz `json:"cancelled_at"`
	Metadata           []byte             `json:"metadata"`
	ID                 pgtype.UUID        `json:"id"`
}

func (q *Queries) UpdateSubscription(ctx context.Context, db DBTX, arg UpdateSubscriptionParams) (*Subscription, error) {
	row := db.QueryRow(ctx, UpdateSubscription,
		arg.Status,
		arg.CurrentPeriodStart,
		arg.CurrentPeriodEnd,
		arg.CancelAtPeriodEnd,
		arg.CancelledAt,
		arg.Metadata,
		arg.ID,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FamilyID,
		&i.PlanID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.CancelAtPeriodEnd,
		&i.CancelledAt,
		&i.ExternalSubscriptionID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UpdateSubscriptionStatus = `-- name: UpdateSubscriptionStatus :one
UPDATE subscriptions SET
    status = $1,
    cancelled_at = $2,
    updated_at = NOW()
WHERE id = $3
RETURNING id, user_id, family_id, plan_id, status, current_period_start, current_period_end, cancel_at_period_end, cancelled_at, external_subscription_id, metadata, created_at, updated_at
`

type UpdateSubscriptionStatusParams struct {
	Status      string             `json:"status"`
	CancelledAt pgtype.Timestamptz `json:"cancelled_at"`
	ID          pgtype.UUID        `json:"id"`
}

func (q *Queries) UpdateSubscriptionStatus(ctx context.Context, db DBTX, arg UpdateSubscriptionStatusParams) (*Subscription, error) {
	row := db.QueryRow(ctx, UpdateSubscriptionStatus, arg.Status, arg.CancelledAt, arg.ID)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FamilyID,
		&i.PlanID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.CancelAtPeriodEnd,
		&i.CancelledAt,
		&i.ExternalSubscriptionID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
