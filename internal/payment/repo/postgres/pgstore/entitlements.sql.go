// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: entitlements.sql

package pgstore

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CheckEntitlement = `-- name: CheckEntitlement :one
SELECT id, user_id, family_id, feature_code, plan_id, subscription_id, status, granted_at, expires_at, usage_limits, metadata, created_at, updated_at FROM entitlements 
WHERE user_id = $1 
  AND feature_code = $2
  AND status = 'active'
  AND (expires_at IS NULL OR expires_at > NOW())
ORDER BY granted_at DESC
LIMIT 1
`

type CheckEntitlementParams struct {
	UserID      string `json:"user_id"`
	FeatureCode string `json:"feature_code"`
}

func (q *Queries) CheckEntitlement(ctx context.Context, db DBTX, arg CheckEntitlementParams) (*Entitlement, error) {
	row := db.QueryRow(ctx, CheckEntitlement, arg.UserID, arg.FeatureCode)
	var i Entitlement
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FamilyID,
		&i.FeatureCode,
		&i.PlanID,
		&i.SubscriptionID,
		&i.Status,
		&i.GrantedAt,
		&i.ExpiresAt,
		&i.UsageLimits,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetEntitlementByID = `-- name: GetEntitlementByID :one
SELECT id, user_id, family_id, feature_code, plan_id, subscription_id, status, granted_at, expires_at, usage_limits, metadata, created_at, updated_at FROM entitlements 
WHERE id = $1
`

func (q *Queries) GetEntitlementByID(ctx context.Context, db DBTX, id pgtype.UUID) (*Entitlement, error) {
	row := db.QueryRow(ctx, GetEntitlementByID, id)
	var i Entitlement
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FamilyID,
		&i.FeatureCode,
		&i.PlanID,
		&i.SubscriptionID,
		&i.Status,
		&i.GrantedAt,
		&i.ExpiresAt,
		&i.UsageLimits,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const InsertEntitlement = `-- name: InsertEntitlement :one
INSERT INTO entitlements (
    user_id, family_id, feature_code, plan_id, subscription_id,
    status, granted_at, expires_at, usage_limits, metadata
) VALUES (
    $1, $2, $3,
    $4, $5,
    $6, $7, $8,
    $9, $10
) RETURNING id, user_id, family_id, feature_code, plan_id, subscription_id, status, granted_at, expires_at, usage_limits, metadata, created_at, updated_at
`

type InsertEntitlementParams struct {
	UserID         string           `json:"user_id"`
	FamilyID       pgtype.Text      `json:"family_id"`
	FeatureCode    string           `json:"feature_code"`
	PlanID         string           `json:"plan_id"`
	SubscriptionID pgtype.Text      `json:"subscription_id"`
	Status         string           `json:"status"`
	GrantedAt      pgtype.Timestamp `json:"granted_at"`
	ExpiresAt      pgtype.Timestamp `json:"expires_at"`
	UsageLimits    []byte           `json:"usage_limits"`
	Metadata       []byte           `json:"metadata"`
}

func (q *Queries) InsertEntitlement(ctx context.Context, db DBTX, arg InsertEntitlementParams) (*Entitlement, error) {
	row := db.QueryRow(ctx, InsertEntitlement,
		arg.UserID,
		arg.FamilyID,
		arg.FeatureCode,
		arg.PlanID,
		arg.SubscriptionID,
		arg.Status,
		arg.GrantedAt,
		arg.ExpiresAt,
		arg.UsageLimits,
		arg.Metadata,
	)
	var i Entitlement
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FamilyID,
		&i.FeatureCode,
		&i.PlanID,
		&i.SubscriptionID,
		&i.Status,
		&i.GrantedAt,
		&i.ExpiresAt,
		&i.UsageLimits,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const ListEntitlementsByUser = `-- name: ListEntitlementsByUser :many
SELECT id, user_id, family_id, feature_code, plan_id, subscription_id, status, granted_at, expires_at, usage_limits, metadata, created_at, updated_at FROM entitlements 
WHERE user_id = $1
ORDER BY granted_at DESC
`

func (q *Queries) ListEntitlementsByUser(ctx context.Context, db DBTX, userID string) ([]*Entitlement, error) {
	rows, err := db.Query(ctx, ListEntitlementsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Entitlement{}
	for rows.Next() {
		var i Entitlement
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FamilyID,
			&i.FeatureCode,
			&i.PlanID,
			&i.SubscriptionID,
			&i.Status,
			&i.GrantedAt,
			&i.ExpiresAt,
			&i.UsageLimits,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListExpiringEntitlements = `-- name: ListExpiringEntitlements :many
SELECT id, user_id, family_id, feature_code, plan_id, subscription_id, status, granted_at, expires_at, usage_limits, metadata, created_at, updated_at FROM entitlements 
WHERE expires_at IS NOT NULL 
  AND expires_at <= NOW() 
  AND status = 'active'
ORDER BY expires_at ASC
`

func (q *Queries) ListExpiringEntitlements(ctx context.Context, db DBTX) ([]*Entitlement, error) {
	rows, err := db.Query(ctx, ListExpiringEntitlements)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Entitlement{}
	for rows.Next() {
		var i Entitlement
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FamilyID,
			&i.FeatureCode,
			&i.PlanID,
			&i.SubscriptionID,
			&i.Status,
			&i.GrantedAt,
			&i.ExpiresAt,
			&i.UsageLimits,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateEntitlementExpiry = `-- name: UpdateEntitlementExpiry :one
UPDATE entitlements 
SET expires_at = $1, updated_at = NOW()
WHERE id = $2
RETURNING id, user_id, family_id, feature_code, plan_id, subscription_id, status, granted_at, expires_at, usage_limits, metadata, created_at, updated_at
`

type UpdateEntitlementExpiryParams struct {
	ExpiresAt pgtype.Timestamp `json:"expires_at"`
	ID        pgtype.UUID      `json:"id"`
}

func (q *Queries) UpdateEntitlementExpiry(ctx context.Context, db DBTX, arg UpdateEntitlementExpiryParams) (*Entitlement, error) {
	row := db.QueryRow(ctx, UpdateEntitlementExpiry, arg.ExpiresAt, arg.ID)
	var i Entitlement
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FamilyID,
		&i.FeatureCode,
		&i.PlanID,
		&i.SubscriptionID,
		&i.Status,
		&i.GrantedAt,
		&i.ExpiresAt,
		&i.UsageLimits,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UpdateEntitlementStatus = `-- name: UpdateEntitlementStatus :one
UPDATE entitlements 
SET status = $1, updated_at = NOW()
WHERE id = $2
RETURNING id, user_id, family_id, feature_code, plan_id, subscription_id, status, granted_at, expires_at, usage_limits, metadata, created_at, updated_at
`

type UpdateEntitlementStatusParams struct {
	Status string      `json:"status"`
	ID     pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateEntitlementStatus(ctx context.Context, db DBTX, arg UpdateEntitlementStatusParams) (*Entitlement, error) {
	row := db.QueryRow(ctx, UpdateEntitlementStatus, arg.Status, arg.ID)
	var i Entitlement
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FamilyID,
		&i.FeatureCode,
		&i.PlanID,
		&i.SubscriptionID,
		&i.Status,
		&i.GrantedAt,
		&i.ExpiresAt,
		&i.UsageLimits,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
