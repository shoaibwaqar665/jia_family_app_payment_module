// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: entitlements.sql

package pgstore

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const CheckEntitlement = `-- name: CheckEntitlement :one
SELECT id, user_id, family_id, feature_code, plan_id, subscription_id, status, granted_at, expires_at, usage_limits, metadata, created_at, updated_at FROM entitlements 
WHERE user_id = $1 
  AND feature_code = $2
  AND status = 'active'
  AND (expires_at IS NULL OR expires_at > NOW())
ORDER BY granted_at DESC
LIMIT 1
`

type CheckEntitlementParams struct {
	UserID      string `json:"user_id"`
	FeatureCode string `json:"feature_code"`
}

func (q *Queries) CheckEntitlement(ctx context.Context, arg CheckEntitlementParams) (*Entitlement, error) {
	row := q.db.QueryRowContext(ctx, CheckEntitlement, arg.UserID, arg.FeatureCode)
	var i Entitlement
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FamilyID,
		&i.FeatureCode,
		&i.PlanID,
		&i.SubscriptionID,
		&i.Status,
		&i.GrantedAt,
		&i.ExpiresAt,
		&i.UsageLimits,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetEntitlementByID = `-- name: GetEntitlementByID :one
SELECT id, user_id, family_id, feature_code, plan_id, subscription_id, status, granted_at, expires_at, usage_limits, metadata, created_at, updated_at FROM entitlements 
WHERE id = $1
`

func (q *Queries) GetEntitlementByID(ctx context.Context, id uuid.UUID) (*Entitlement, error) {
	row := q.db.QueryRowContext(ctx, GetEntitlementByID, id)
	var i Entitlement
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FamilyID,
		&i.FeatureCode,
		&i.PlanID,
		&i.SubscriptionID,
		&i.Status,
		&i.GrantedAt,
		&i.ExpiresAt,
		&i.UsageLimits,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const InsertEntitlement = `-- name: InsertEntitlement :one
INSERT INTO entitlements (
    user_id, family_id, feature_code, plan_id, subscription_id,
    status, granted_at, expires_at, usage_limits, metadata
) VALUES (
    $1, $2, $3,
    $4, $5,
    $6, $7, $8,
    $9, $10
) RETURNING id, user_id, family_id, feature_code, plan_id, subscription_id, status, granted_at, expires_at, usage_limits, metadata, created_at, updated_at
`

type InsertEntitlementParams struct {
	UserID         string                `json:"user_id"`
	FamilyID       sql.NullString        `json:"family_id"`
	FeatureCode    string                `json:"feature_code"`
	PlanID         string                `json:"plan_id"`
	SubscriptionID sql.NullString        `json:"subscription_id"`
	Status         string                `json:"status"`
	GrantedAt      time.Time             `json:"granted_at"`
	ExpiresAt      sql.NullTime          `json:"expires_at"`
	UsageLimits    pqtype.NullRawMessage `json:"usage_limits"`
	Metadata       pqtype.NullRawMessage `json:"metadata"`
}

func (q *Queries) InsertEntitlement(ctx context.Context, arg InsertEntitlementParams) (*Entitlement, error) {
	row := q.db.QueryRowContext(ctx, InsertEntitlement,
		arg.UserID,
		arg.FamilyID,
		arg.FeatureCode,
		arg.PlanID,
		arg.SubscriptionID,
		arg.Status,
		arg.GrantedAt,
		arg.ExpiresAt,
		arg.UsageLimits,
		arg.Metadata,
	)
	var i Entitlement
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FamilyID,
		&i.FeatureCode,
		&i.PlanID,
		&i.SubscriptionID,
		&i.Status,
		&i.GrantedAt,
		&i.ExpiresAt,
		&i.UsageLimits,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const ListEntitlementsByUser = `-- name: ListEntitlementsByUser :many
SELECT id, user_id, family_id, feature_code, plan_id, subscription_id, status, granted_at, expires_at, usage_limits, metadata, created_at, updated_at FROM entitlements 
WHERE user_id = $1
ORDER BY granted_at DESC
`

func (q *Queries) ListEntitlementsByUser(ctx context.Context, userID string) ([]*Entitlement, error) {
	rows, err := q.db.QueryContext(ctx, ListEntitlementsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Entitlement{}
	for rows.Next() {
		var i Entitlement
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FamilyID,
			&i.FeatureCode,
			&i.PlanID,
			&i.SubscriptionID,
			&i.Status,
			&i.GrantedAt,
			&i.ExpiresAt,
			&i.UsageLimits,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListExpiringEntitlements = `-- name: ListExpiringEntitlements :many
SELECT id, user_id, family_id, feature_code, plan_id, subscription_id, status, granted_at, expires_at, usage_limits, metadata, created_at, updated_at FROM entitlements 
WHERE expires_at IS NOT NULL 
  AND expires_at <= NOW() 
  AND status = 'active'
ORDER BY expires_at ASC
`

func (q *Queries) ListExpiringEntitlements(ctx context.Context) ([]*Entitlement, error) {
	rows, err := q.db.QueryContext(ctx, ListExpiringEntitlements)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Entitlement{}
	for rows.Next() {
		var i Entitlement
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FamilyID,
			&i.FeatureCode,
			&i.PlanID,
			&i.SubscriptionID,
			&i.Status,
			&i.GrantedAt,
			&i.ExpiresAt,
			&i.UsageLimits,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateEntitlementExpiry = `-- name: UpdateEntitlementExpiry :one
UPDATE entitlements 
SET expires_at = $1, updated_at = NOW()
WHERE id = $2
RETURNING id, user_id, family_id, feature_code, plan_id, subscription_id, status, granted_at, expires_at, usage_limits, metadata, created_at, updated_at
`

type UpdateEntitlementExpiryParams struct {
	ExpiresAt sql.NullTime `json:"expires_at"`
	ID        uuid.UUID    `json:"id"`
}

func (q *Queries) UpdateEntitlementExpiry(ctx context.Context, arg UpdateEntitlementExpiryParams) (*Entitlement, error) {
	row := q.db.QueryRowContext(ctx, UpdateEntitlementExpiry, arg.ExpiresAt, arg.ID)
	var i Entitlement
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FamilyID,
		&i.FeatureCode,
		&i.PlanID,
		&i.SubscriptionID,
		&i.Status,
		&i.GrantedAt,
		&i.ExpiresAt,
		&i.UsageLimits,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UpdateEntitlementStatus = `-- name: UpdateEntitlementStatus :one
UPDATE entitlements 
SET status = $1, updated_at = NOW()
WHERE id = $2
RETURNING id, user_id, family_id, feature_code, plan_id, subscription_id, status, granted_at, expires_at, usage_limits, metadata, created_at, updated_at
`

type UpdateEntitlementStatusParams struct {
	Status string    `json:"status"`
	ID     uuid.UUID `json:"id"`
}

func (q *Queries) UpdateEntitlementStatus(ctx context.Context, arg UpdateEntitlementStatusParams) (*Entitlement, error) {
	row := q.db.QueryRowContext(ctx, UpdateEntitlementStatus, arg.Status, arg.ID)
	var i Entitlement
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FamilyID,
		&i.FeatureCode,
		&i.PlanID,
		&i.SubscriptionID,
		&i.Status,
		&i.GrantedAt,
		&i.ExpiresAt,
		&i.UsageLimits,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
