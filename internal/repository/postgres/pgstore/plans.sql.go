// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: plans.sql

package pgstore

import (
	"context"
	"database/sql"

	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const GetPlanByID = `-- name: GetPlanByID :one
SELECT id, name, description, feature_codes, billing_cycle, price_cents, currency, max_users, usage_limits, metadata, active, created_at, updated_at FROM plans 
WHERE id = $1 AND active = true
`

func (q *Queries) GetPlanByID(ctx context.Context, id string) (*Plan, error) {
	row := q.db.QueryRowContext(ctx, GetPlanByID, id)
	var i Plan
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		pq.Array(&i.FeatureCodes),
		&i.BillingCycle,
		&i.PriceCents,
		&i.Currency,
		&i.MaxUsers,
		&i.UsageLimits,
		&i.Metadata,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const InsertPlan = `-- name: InsertPlan :one
INSERT INTO plans (
    id, name, description, feature_codes, billing_cycle,
    price_cents, currency, max_users, usage_limits, metadata, active
) VALUES (
    $1, $2, $3, 
    $4, $5,
    $6, $7, $8,
    $9, $10, $11
) RETURNING id, name, description, feature_codes, billing_cycle, price_cents, currency, max_users, usage_limits, metadata, active, created_at, updated_at
`

type InsertPlanParams struct {
	ID           string                `json:"id"`
	Name         string                `json:"name"`
	Description  sql.NullString        `json:"description"`
	FeatureCodes []string              `json:"feature_codes"`
	BillingCycle sql.NullString        `json:"billing_cycle"`
	PriceCents   int32                 `json:"price_cents"`
	Currency     string                `json:"currency"`
	MaxUsers     sql.NullInt32         `json:"max_users"`
	UsageLimits  pqtype.NullRawMessage `json:"usage_limits"`
	Metadata     pqtype.NullRawMessage `json:"metadata"`
	Active       bool                  `json:"active"`
}

func (q *Queries) InsertPlan(ctx context.Context, arg InsertPlanParams) (*Plan, error) {
	row := q.db.QueryRowContext(ctx, InsertPlan,
		arg.ID,
		arg.Name,
		arg.Description,
		pq.Array(arg.FeatureCodes),
		arg.BillingCycle,
		arg.PriceCents,
		arg.Currency,
		arg.MaxUsers,
		arg.UsageLimits,
		arg.Metadata,
		arg.Active,
	)
	var i Plan
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		pq.Array(&i.FeatureCodes),
		&i.BillingCycle,
		&i.PriceCents,
		&i.Currency,
		&i.MaxUsers,
		&i.UsageLimits,
		&i.Metadata,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const ListActivePlans = `-- name: ListActivePlans :many
SELECT id, name, description, feature_codes, billing_cycle, price_cents, currency, max_users, usage_limits, metadata, active, created_at, updated_at FROM plans 
WHERE active = true 
ORDER BY created_at DESC
`

func (q *Queries) ListActivePlans(ctx context.Context) ([]*Plan, error) {
	rows, err := q.db.QueryContext(ctx, ListActivePlans)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Plan{}
	for rows.Next() {
		var i Plan
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			pq.Array(&i.FeatureCodes),
			&i.BillingCycle,
			&i.PriceCents,
			&i.Currency,
			&i.MaxUsers,
			&i.UsageLimits,
			&i.Metadata,
			&i.Active,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdatePlanActive = `-- name: UpdatePlanActive :one
UPDATE plans 
SET active = $1, updated_at = NOW()
WHERE id = $2
RETURNING id, name, description, feature_codes, billing_cycle, price_cents, currency, max_users, usage_limits, metadata, active, created_at, updated_at
`

type UpdatePlanActiveParams struct {
	Active bool   `json:"active"`
	ID     string `json:"id"`
}

func (q *Queries) UpdatePlanActive(ctx context.Context, arg UpdatePlanActiveParams) (*Plan, error) {
	row := q.db.QueryRowContext(ctx, UpdatePlanActive, arg.Active, arg.ID)
	var i Plan
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		pq.Array(&i.FeatureCodes),
		&i.BillingCycle,
		&i.PriceCents,
		&i.Currency,
		&i.MaxUsers,
		&i.UsageLimits,
		&i.Metadata,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
